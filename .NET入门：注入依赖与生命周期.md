# .NET入门 : 注入依赖与生命周期💗

## ***Part *0****  对象资源的分类 💛  

我们知道C#有个垃圾回收器GC来管理对象的销毁，和回收内存。

对象大致可以分为两类:托管和非托管。

>托管资源（Managed Resources）🧲
托管资源是由.NET运行时管理的资源，它们存储在托管堆（Managed Heap）上。以下是一些常见的托管资源：
>对象实例：所有通过C#类创建的对象，如MyClass myObject = new MyClass();。
字符串：string类型的实例，如string myString = "Hello, World!";。
数组：任何类型的数组，如int[] myArray = new int[10];。
委托：Delegate类型的对象，如事件处理器。
装箱值类型：值类型被装箱后，如object myObject = 42;。
泛型：泛型类型的对象，如List<int> myList = new List<int>();。

>非托管资源（Unmanaged Resources）🔨
非托管资源不是由.NET运行时管理的资源，它们通常与操作系统或硬件直接交互。以下是一些常见的非托管资源：
>文件句柄：通过File.Open、FileStream等创建的文件句柄。
网络资源：如TCP连接、套接字（Socket）等。
数据库连接：如ADO.NET中的SqlConnection、OracleConnection等。
操作系统句柄：如Windows API中的窗口句柄、GDI对象句柄等。
非托管内存：通过非托管代码（如C或C++）分配的内存，如使用Marshal.AllocHGlobal分配的内存。
硬件资源：如打开的设备、音频/视频流等。
COM对象：组件对象模型（COM）对象，它们通常由非托管代码实现.

我们都知道GC的回收机制使我们控制不了的，一些托管资源我们有些时候希望他在特定的时间再被回收，这个时候我们就可以使用依赖注入。

所谓依赖注入就是谁调用资源，谁new新的资源，然后用完就回收。

## ***Part *1****  依赖对象中的对象的生命周期 🛢 

在一般的设计流程当中，我们都是先new一个对象，然后再在其他地方调用。


瞬态（Transient）：每次请求服务时，容器都会创建一个新的实例。这意味着每次注入ITransientService时，都会得到一个全新的对象实例。瞬态生命周期类似于每次使用资源时都new一个新的资源，用完即丢弃。它适用于轻量级和无状态的服务。

作用域（Scoped）：在相同的作用域内，每次请求服务时，都会使用相同的实例。作用域生命周期通常用于Web应用中，每个HTTP请求都会创建一个新的作用域。在这个作用域内，所有注入IScopedService的服务都会共享相同的实例。这适用于需要在请求范围内保持状态的服务，例如数据库上下文。

单例（Singleton）：整个应用程序的生命周期内，只创建一个实例。单例生命周期在整个应用程序中只创建一次服务实例，并且所有注入ISingletonService的点都会共享这个相同的实例。这适用于单例模式的服务，如配置信息、日志服务或全局缓存。