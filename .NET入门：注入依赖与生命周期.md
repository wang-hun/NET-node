# .NET入门 : 注入依赖与生命周期💗

## ***Part *0****  对象资源的分类 💛  

我们知道C#有个垃圾回收器GC来管理对象的销毁，和回收内存。

对象大致可以分为两类:托管和非托管。

>托管资源（Managed Resources）🧲
托管资源是由.NET运行时管理的资源，它们存储在托管堆（Managed Heap）上。以下是一些常见的托管资源：
>对象实例：所有通过C#类创建的对象，如MyClass myObject = new MyClass();。
字符串：string类型的实例，如string myString = "Hello, World!";。
数组：任何类型的数组，如int[] myArray = new int[10];。
委托：Delegate类型的对象，如事件处理器。
装箱值类型：值类型被装箱后，如object myObject = 42;。
泛型：泛型类型的对象，如List<int> myList = new List<int>();。

>非托管资源（Unmanaged Resources）🔨
非托管资源不是由.NET运行时管理的资源，它们通常与操作系统或硬件直接交互。以下是一些常见的非托管资源：
>文件句柄：通过File.Open、FileStream等创建的文件句柄。
网络资源：如TCP连接、套接字（Socket）等。
数据库连接：如ADO.NET中的SqlConnection、OracleConnection等。
操作系统句柄：如Windows API中的窗口句柄、GDI对象句柄等。
非托管内存：通过非托管代码（如C或C++）分配的内存，如使用Marshal.AllocHGlobal分配的内存。
硬件资源：如打开的设备、音频/视频流等。
COM对象：组件对象模型（COM）对象，它们通常由非托管代码实现.

我们都知道GC的回收机制使我们控制不了的，一些托管资源我们有些时候希望他在特定的时间再被回收，这个时候我们就可以使用依赖注入。

所谓依赖注入就是谁调用资源，谁new新的资源，然后用完就回收。

## ***Part *1****  依赖注入对象的生命周期 🛢


在一般的设计流程当中，我们都是先new一个对象，然后再在其他地方调用。比如下面的这个单例模式。

```csharp

class SunLunkySun
{
    private static SunLunkySun DoublieSun;

    public static  SunLunkySun doublieSun()
    {

        if (DoublieSun == null)
        {
            DoublieSun = new SunLunkySun();
        }
        return DoublieSun;
    }


    public DateTime useTime { get; set; }
    private SunLunkySun()
    {
        useTime = DateTime.Now;
    }

    public void callMe(string str)
    {

        Console.WriteLine($"{str}?马上来！");
    }

}

class Program
{
    public static void Main(string[] args)
    {
        var doublesun = SunLunkySun.doublieSun();
        var number = doublesun.useTime;
        doublesun.callMe($"{number}");
    }

}
```

上述是一个很简单的单线程静态程序，我们的🌞sunsun同学使用了单例模式，会在这整个程序关闭的时候，被GC回收掉。

但如果我们是一个多线程程序，使用静态单例将会产生不少问题，首先是对于同一个容器的读取和写入可能造成死锁。
其次是，如果这个程序是一个发布到服务器上一直运行的程序，很显然☀永恒存在，永远不会被销毁。这意味着如果我们每次启动一个子程序，在运行完毕之后，需要手动重置这个子程序，才能保证上一次的运行不会影响下一次的运行。
比如这个例子🍐中useTime。

为了解决这些传统模式带来的问题，我们来介绍一种新的设计模式，注入依赖。
简单描述就是，谁需要使用，谁再创建，用完既销毁。
让new对象的方式彻底反过来，先调用，再new对象。

依赖注入有三种生命周期模式：

>瞬态（Transient）：每次请求服务时，容器都会创建一个新的实例。这意味着每次注入ITransientService时，都会得到一个全新的对象实例。瞬态生命周期类似于每次使用资源时都new一个新的资源，用完即丢弃。它适用于轻量级和无状态的服务。

>作用域（Scoped）：在相同的作用域内，每次请求服务时，都会使用相同的实例。作用域生命周期通常用于Web应用中，每个HTTP请求都会创建一个新的作用域。在这个作用域内，所有注入IScopedService的服务都会共享相同的实例。这适用于需要在请求范围内保持状态的服务，例如数据库上下文。

>单例（Singleton）：整个应用程序的生命周期内，只创建一个实例。单例生命周期在整个应用程序中只创建一次服务实例，并且所有注入ISingletonService的点都会共享这个相同的实例。这适用于单例模式的服务，如配置信息、日志服务或全局缓存。


## ***Part *2****  依赖注入的使用 🥑