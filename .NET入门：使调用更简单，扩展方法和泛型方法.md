
# .NET入门：使调用更简单，扩展方法和泛型方法

## ***Part *0**** 使用扩展方法，让实例也可以调用通用方法⚓

简单介绍一下扩展方法有什么用。我们还是举个例子💦,  
我们还是有请🤖GPT为我们生成一段函数

```Csharp
public class StringAnalyzer
{
    public static int CountA(string str)
    {
        if (string.IsNullOrEmpty(str))
            return 0;

        int count = 0;
        foreach (char c in str)
        {
            if (char.ToUpper(c) == 'A')
                count++;
        }
        return count;
    }
}
```

这个⚙函数的作用是返回一个字符串中包含几个‘A’。  
如果你需要使用这个函数应该给一个参数。

```csharp
var number= StringAnalyzer.CountA("AAAAA2345");
```
接下来我们来使用扩展方法，这次我们写一个统计字符串里有几个B。  

```Csharp

    public static int CountB( this string str)
    {
        if (string.IsNullOrEmpty(str))
            return 0;

        int count = 0;
        foreach (char c in str)
        {
            if (char.ToUpper(c) == 'B')
                count++;
        }
        return count;
    }

```
只需要给参数加个this就行了， 🌸**C#规定扩展方法只能写在静态类里** 🌸，所以你也需要给类添加静态修饰。

```Csharp
public static class StringAnalyzer
```

那么我们可以试试如何使用这个扩展方法。

```Csharp
var number2 = "BBBABBAAA".CountB(); 
```

对，只需要对符合this修饰的参数类型点一下就行了。只要使用扩展方法的类可以访问到定义类，就可以使用扩展方法。也就是说扩展方法public，并且包含的类被引用了，那么就可以被使用。  
   🌮 🌮 🌮  
扩展方法和普通方法的定义没有什么区别，可以被重载，同样需要注意函数名的命名规范。挂载的this参数有且只能有一个，并且必须作为函数的第一个参数。其他参数没有限制。  
   🍥 🍥 🍥
虽然被标记了this，但和一般的函数一样，参数以值传递。也就是说你似乎对this参数修改值，如果this参数是一个值类型，那么修改是不起作用的。  
 💥***你不能对this参数声明ref或者out！*** 💥  


 至此，扩展函数的部分讲完了，使用扩展函数能简化调用。  
 至于是否要使用，这点就仁者见仁智者见智了。  

## ***Part *1**** 什么是泛型✨  
 
泛型的定义很简单，就是让你的代码与类型无关，这就是泛型，说起来很简单，但使用分很多方面。泛型集合，泛型类、泛型接口、泛型方法……  
任何你使用了类型的地方都可以使用泛型。

我们先来看你最常使用的泛型集合。  
我觉得这一部分不需要我特别的去讲，因为你一直都在使用。我们来举个例子💦

```Csharp
List<int> A= new List<int>();
Dictionary<int,string> B= new Dictionary<int,string>();
```

被尖括号包起来的就是泛型，字典和列表，以及其他集合类。都可以存储所有类型的数据，与数据类型无关，这就是泛型。🧱

## ***Part *2**** 泛型方法，你还在为类型不确定而苦恼吗？

前文已经讲了，所谓泛型，就是你的代码不受到类型的约束就叫泛型。对于一个函数而言，我们往往希望他的参数或者某一部分，类型可以是多种，而不是特定的某种。  

我们还是有请GPT生成一些定义数据：

```C#
public class A
{
}

public class A1 : A
{
    public string ClassName { get; set; } = "A1";
}

public class A2 : A
{
    public string ClassName { get; set; } = "A2";
}

public class A3 : A
{
    public string ClassName { get; set; } = "A3";
}
```  
