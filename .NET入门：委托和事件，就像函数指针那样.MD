[TOC]

# .NET入门: 委托和事件，就像函数指针那样  

## ***Part **0***** 还记得函数指针吗？🛴  

学过C或C++的同学肯定学过函数指针。  
也就是将一个函数装进指针里，这样你就能像一般的变量一样，用函数赋给一个参数，之后交给对应的其他函数。  

这里给出一段由🤖GPT给出的示例代码，就是个可以通过给函数指针赋不同的函数，就可以实现不同的运算🧮。

```C
#include <stdio.h>

// 定义两个函数
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

// 定义一个函数指针类型，它可以指向接受两个int参数并返回int的函数
typedef int (*FuncPtr)(int, int);

int main() {
    int num1 = 10, num2 = 5, result;

    // 将函数指针指向add函数
    FuncPtr operation = add;
    result = operation(num1, num2); // 通过函数指针调用add函数
    printf("The result of addition is: %d\n", result);

    // 将函数指针指向subtract函数
    operation = subtract;
    result = operation(num1, num2); // 通过函数指针调用subtract函数
    printf("The result of subtraction is: %d\n", result);

    // 使用函数指针数组
    FuncPtr operations[] = {add, subtract};
    int choice = 1; // 假设用户选择第一个操作，即加法

    // 根据用户的选择调用相应的函数
    if(choice >= 1 && choice <= 2) {
        result = operations[choice - 1](num1, num2);
        printf("The result of operation %d is: %d\n", choice, result);
    }

    return 0;
}z#include <stdio.h>

// 定义两个函数
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

// 定义一个函数指针类型，它可以指向接受两个int参数并返回int的函数
typedef int (*FuncPtr)(int, int);

int main() {
    int num1 = 10, num2 = 5, result;

    // 将函数指针指向add函数
    FuncPtr operation = add;
    result = operation(num1, num2); // 通过函数指针调用add函数
    printf("The result of addition is: %d\n", result);

    // 将函数指针指向subtract函数
    operation = subtract;
    result = operation(num1, num2); // 通过函数指针调用subtract函数
    printf("The result of subtraction is: %d\n", result);

    // 使用函数指针数组
    FuncPtr operations[] = {add, subtract};
    int choice = 1; // 假设用户选择第一个操作，即加法

    // 根据用户的选择调用相应的函数
    if(choice >= 1 && choice <= 2) {
        result = operations[choice - 1](num1, num2);
        printf("The result of operation %d is: %d\n", choice, result);
    }

    return 0;
}
```  

学完这个之后你可能会觉得，这个毫无作用。🎐为什么我不直接声明一个函数，💥还需要把函数装进一个指针里，再调用它？  
看完本文的事件，你可能会有所收获。  

## ***Part **1***** 委托、事件无处不在  ⛩  

如果你使用winfrom，那你一定经常和事件打交道。所有的事件都由VS给你自动生成，自动绑定了。也许你并不关心实现的具体细节。  

我们以按钮点击🕹，输出一个hello world来举例🎛。  
我们写一个控制台程序来模拟这一过程。  
因为按钮按下，操作系统返回一个消息，然后传给窗体这个过程很复杂，我们简化一下，简化成是对isClick🖱这个值的修改操作。

```csharp
var button_1 = new Button();

class Button
{
    bool isClick { get; set; } = false;
}
```  

这是我们模拟的一个按钮，当它的被按下，也就是isClick被修改时，我们又应该怎么知道呢？  

学过封装的同学会说，简单，修改set函数就行了。  

```csharp
var button_1 = new Button();
button_1.IsClick = true;
class Button
{
    bool isClick;
    public bool IsClick
    {
        get => isClick;
        set{
            isClick = value;
            Console.WriteLine("Hello World");

        }
    }
    public Button()
    {
        isClick = false;
    }
}
```
没什么问题，但是如果我之后又想输出"see you again sunsun"🌞,该怎么办呢？  
我们知道点击事件函数是可以由用户决定，并不是被封装好，不可修改的。

这个时候我们来使用委托。

```csharp
class Button
{
    public delegate void onClick();
    public onClick Click;
    bool isClick;
    public bool IsClick
    {
        get => isClick;
        set{
            isClick = value;
            if (Click != null) {
                Click();
            }

        }
    }
    public Button()
    {
        isClick = false;
    }
}
``` 
delegate 就是委托，需要注意的是委托是一个类型，不是一个变量，更不是一个成员。就像枚举和结构体一样。你必须先声明一种委托类型，然后才能定义这种委托变量或者委托成员。

由于这个Click委托成员里可能什么都没有，所以我们运行的时候必须判断是不是空。  
